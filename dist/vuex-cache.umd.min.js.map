{"version":3,"file":"vuex-cache.umd.min.js","sources":["../src/vuex-cache.js"],"sourcesContent":["/**\n * Check if value is an object.\n * @param {any} value\n * @returns {value is Object}\n */\nconst isObject = (value) => {\n  return !!value && typeof value === 'object'\n}\n\nconst LOCAL_STORAGE_KEY = 'VUEX-CACHE-STATE'\nconst createCache = (options) => (store) => defineCache(store, options)\n\nconst createState = () => {\n  const storageData = localStorage.getItem(STORAGE_NAME);\n  const cacheData = storageData && JSON.parse(storageData) || [];\n  if (!!storageData) {\n    for (const item of cacheData) {\n      item[1].value = new Promise((resolve) => {\n        resolve(item[1].value);\n      })\n    }\n  }\n  return new Map(cacheData);\n}\n\nconst saveToLocalStorage = () => {\n  window.addEventListener(\"beforeunload\", function (event) {\n    const localSrotageData = Array.from(state.entries());\n    for (const item of localSrotageData) {\n      if (item[1].value instanceof Promise) {\n        item[1].value.then(result => {\n          item[1].value = result;\n        })\n      }\n    }\n    console.log('saveToLocalStorage', localSrotageData)\n    localStorage.setItem(STORAGE_NAME, JSON.stringify(localSrotageData));\n  });\n}\n\n/**\n * Type alias for Store or ActionContext instances.\n * @typedef {import('vuex').Store<any> | import('vuex').ActionContext<any, any>} Store\n */\n\n/**\n * Convert value to `string`.\n * @param {any} value\n * @returns {string}\n */\nconst toString = (value) => {\n  return isObject(value) ? JSON.stringify(value) : String(value)\n}\n\n/**\n * Dispatch's options object.\n * @typedef {import('vuex').DispatchOptions & { timeout: number }} DispatchOptions\n */\n\n/**\n * Dispatch's payload object.\n * @typedef {import('vuex').Payload & { timeout: number }} Payload\n */\n\n/**\n * Type alias for Dispatch parameters.\n * @typedef {[string, any?, DispatchOptions?]|[Payload, DispatchOptions?]} DispatchParams\n */\n\n/**\n * Resolve Dispatch parameters.\n * @param {DispatchParams} params\n * @returns {[string, Payload?, DispatchOptions?]}\n */\nconst resolveParams = (params) => {\n  return isObject(params[0]) ? [params[0].type, params[0], params[1]] : params\n}\n\nconst GenerateKeyError = new Error(\"Can't generate key from parameters.\")\n\n/**\n * Generate key from Dispatch parameters.\n * @param {DispatchParams} params\n * @returns {string|Error}\n */\nconst generateKey = (params) => {\n  try {\n    const [type, payload] = resolveParams(params)\n    return `${type}:${toString(payload)}`\n  } catch (_) {\n    return GenerateKeyError\n  }\n}\n\n/**\n * Check if value has timeout property.\n * @param {any} value\n * @returns {value is { timeout: number }}\n */\nconst hasTimeout = (value) => {\n  return isObject(value) && typeof value.timeout === 'number'\n}\n\n/**\n * Type alias for options object.\n * @typedef {{ timeout?: number }} Options\n */\n\n/**\n * Resolve timeout from parameters and plugin options.\n * @param {DispatchParams} params\n * @param {Options} [pluginOptions]\n * @returns {number}\n */\nconst resolveTimeout = (params, pluginOptions) => {\n  const dispatchOptions = typeof params[0] === 'string' ? params[2] : params[0]\n  if (hasTimeout(dispatchOptions)) {\n    return dispatchOptions.timeout\n  } else if (hasTimeout(pluginOptions)) {\n    return pluginOptions.timeout\n  }\n  return 0\n}\n\n/**\n * Check if value (time) is expired.\n * @param {number} [expiresIn]\n * @returns {boolean}\n */\nconst isExpired = (expiresIn) => {\n  return !!expiresIn && Date.now() > expiresIn\n}\n\n/**\n * Cache's state record.\n * @typedef {{ expiresIn?: number, value: Promise<any> }} CacheRecord\n */\n\n/**\n * Cache's state.\n * @type {Map<string, CacheRecord>}\n */\nconst state = createState();\n\nsaveToLocalStorage();\n/**\n * Define cache property to store, or action context, object.\n * @param {Store} store\n * @param {Options} [options]\n */\nconst defineCache = (store, options) => {\n  const cache = {\n    /**\n     * Dispatch an action and set it on cache.\n     * @param  {...DispatchParams} params\n     * @returns {Promise<any>}\n     */\n    dispatch(...params) {\n      const key = generateKey(params)\n\n      if (key === GenerateKeyError) {\n        // Fallback on generateKey errors.\n        return store.dispatch.apply(store, params)\n      }\n\n      const { value, expiresIn } = state.get(key) || {}\n\n      if (!!value && !isExpired(expiresIn)) {\n        return value\n      }\n\n      const timeout = resolveTimeout(params, options)\n\n      const record = {\n        expiresIn: timeout ? Date.now() + timeout : undefined,\n        value: store.dispatch.apply(store, params),\n      }\n\n      state.set(key, record)\n      console.log(value, 'check');\n      return record.value.catch((error) => {\n        state.delete(key)\n        return Promise.reject(error)\n      })\n    },\n\n    /**\n     * Check if an action dispatch is on cache.\n     * @param  {...DispatchParams} params\n     * @returns {boolean}\n     */\n    has(...params) {\n      const key = generateKey(params)\n\n      if (key === GenerateKeyError) {\n        // Fallback on generateKey errors.\n        return false\n      }\n\n      const record = state.get(key)\n      return isObject(record) && !isExpired(record.expiresIn)\n    },\n\n    /**\n     * Clear cache. Returns `true` if cache was cleared and `false` otherwise.\n     * If using the type parameter, only actions with the specified type are\n     * deleted from cache and the number of deleted keys is returned.\n     * @returns {boolean|number}\n     */\n    clear(...params) {\n      const [type] = resolveParams(params)\n      if (type) {\n        return Array.from(state.keys())\n          .filter((key) => key.split(':')[0] === type)\n          .reduce((count, key) => count + state.delete(key), 0)\n      }\n      return !!state.clear()\n    },\n\n    /**\n     * Delete an action dispatch from cache. Returns `true` if it was deleted\n     * and `false` otherwise.\n     * @returns {boolean}\n     */\n    delete(...params) {\n      const key = generateKey(params)\n\n      if (key === GenerateKeyError) {\n        // Fallback on generateKey errors.\n        return false\n      }\n\n      return state.delete(key)\n    },\n\n    state() {\n      return state\n    },\n  }\n\n  Object.defineProperty(store, 'cache', {\n    value: cache,\n    writable: false,\n    enumerable: true,\n    configurable: false,\n  })\n\n  for (const namespace in store._modulesNamespaceMap) {\n    const module = getModuleByNamespace(store, 'mapCacheActions', namespace)\n\n    Object.defineProperty(module.context, 'cache', {\n      value: cache,\n      writable: false,\n      enumerable: true,\n      configurable: false,\n    })\n  }\n}\n\n/**\n * Normalize the map\n * normalizeMap([1, 2, 3]) => [ { key: 1, val: 1 }, { key: 2, val: 2 }, { key: 3, val: 3 } ]\n * normalizeMap({a: 1, b: 2, c: 3}) => [ { key: 'a', val: 1 }, { key: 'b', val: 2 }, { key: 'c', val: 3 } ]\n * @param {Array|Object} map\n * @return {Object}\n */\nconst normalizeMap = (map) => {\n  return Array.isArray(map)\n    ? map.map((key) => ({ key, val: key }))\n    : Object.keys(map).map((key) => ({ key, val: map[key] }))\n}\n\n/**\n * Search a special module from store by namespace. if module not exist, print error message.\n * @param {Object} store\n * @param {String} helper\n * @param {String} namespace\n * @return {Object}\n */\nconst getModuleByNamespace = (store, helper, namespace) => {\n  const module = store._modulesNamespaceMap[namespace]\n  if (process.env.NODE_ENV !== 'production' && !module) {\n    console.error(\n      `[vuex-cache] module namespace not found in ${helper}(): ${namespace}`,\n    )\n  }\n  return module\n}\n\n/**\n * Return a function expect two param contains namespace and map. it will normalize the namespace and then the param's function will handle the new namespace and the map.\n * @param {Function} fn\n * @return {Function}\n */\nconst normalizeNamespace = (fn) => {\n  return (namespace, map) => {\n    if (typeof namespace !== 'string') {\n      map = namespace\n      namespace = ''\n    } else if (namespace.charAt(namespace.length - 1) !== '/') {\n      namespace += '/'\n    }\n    return fn(namespace, map)\n  }\n}\n\n/**\n * Type alias for Action.\n * @typedef {import('vuex').Action<any, any>} Action\n */\n\n/**\n * Create cache with options and define it on action context instance.\n * @param {Action} action\n * @param {Options} [options]\n * @returns {Action}\n */\nexport const cacheAction = (action, options) =>\n  function (context, payload) {\n    defineCache(context, options)\n    return action.call(this, context, payload)\n  }\n\n/**\n * Create cache actions object to map to a component\n * @param {String} namespace\n * @param {Array} actions\n * @returns {Object}\n */\nexport const mapCacheActions = normalizeNamespace((namespace, actions) => {\n  const res = {}\n  normalizeMap(actions).forEach(({ key, val }) => {\n    res[key] = function mappedAction(...args) {\n      let dispatch = this.$store.cache.dispatch\n\n      if (namespace) {\n        const module = getModuleByNamespace(\n          this.$store,\n          'mapCacheActions',\n          namespace,\n        )\n        if (!module) {\n          return\n        }\n        // dispatch = module.context.cache.dispatch;\n        dispatch =\n          typeof val === 'function'\n            ? (type, ...payload) => {\n                module.context.cache.dispatch.call(\n                  this.$store.cache,\n                  `${namespace}${type}`,\n                  ...payload,\n                )\n              }\n            : module.context.cache.dispatch\n      }\n\n      return typeof val === 'function'\n        ? val.call(this, dispatch, ...args)\n        : dispatch.call(this.$store.cache, `${namespace}${val}`, ...args)\n    }\n  })\n  return res\n})\n\n/**\n * Create cache with options and define it on store instance.\n * @param {Options} options\n * @returns {(store: Store) => void}\n */\n\n\n\nexport default createCache\n"],"names":["const","isObject","value","resolveParams","params","type","GenerateKeyError","Error","generateKey","payload","ref","JSON","stringify","String","_","hasTimeout","timeout","resolveTimeout","pluginOptions","dispatchOptions","isExpired","expiresIn","Date","now","state","storageData","localStorage","getItem","STORAGE_NAME","cacheData","parse","loop","item","Promise","resolve","i","list","Map","createState","window","addEventListener","event","localSrotageData","Array","from","entries","then","result","console","log","setItem","fn","defineCache","store","options","cache","dispatch","key","apply","get","record","undefined","set","catch","error","delete","reject","has","clear","keys","filter","split","reduce","count","namespace","Object","defineProperty","writable","enumerable","configurable","_modulesNamespaceMap","module","getModuleByNamespace","context","helper","mapCacheActions","actions","res","map","isArray","val","forEach","let","this","$store","len","arguments","call","concat","args","charAt","length","action"],"mappings":"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"}